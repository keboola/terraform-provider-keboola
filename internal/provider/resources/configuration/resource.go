package configuration

import (
	"context"
	"fmt"
	"os"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/keboola/go-client/pkg/keboola"

	"github.com/keboola/terraform-provider-keboola/internal/provider/abstraction"
	"github.com/keboola/terraform-provider-keboola/internal/providermodels"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ resource.Resource = &Resource{
		base:   abstraction.BaseResource[ConfigModel, *keboola.ConfigWithRows]{},
		client: nil,
		isTest: false,
	}
	_ resource.ResourceWithConfigure = &Resource{
		base:   abstraction.BaseResource[ConfigModel, *keboola.ConfigWithRows]{},
		client: nil,
		isTest: false,
	}
)

// NewResource is a helper function to simplify the provider implementation.
func NewResource() *Resource {
	return &Resource{
		base:   abstraction.BaseResource[ConfigModel, *keboola.ConfigWithRows]{},
		client: nil,
		isTest: false,
	}
}

// Resource is the configuration resource implementation.
type Resource struct {
	// Base functionality with config model specifics
	base abstraction.BaseResource[ConfigModel, *keboola.ConfigWithRows]

	// Direct access to the API client for specific operations
	client *keboola.AuthorizedAPI
	isTest bool
}

// Metadata returns the resource type name.
func (r *Resource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_component_configuration"
}

// Schema defines the schema for the resource.
func (r *Resource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description:         "Manages component configurations (https://keboola.docs.apiary.io/#reference/components-and-configurations).", //nolint: lll
		MarkdownDescription: "Manages component configurations (https://keboola.docs.apiary.io/#reference/components-and-configurations).", //nolint: lll
		Blocks:              map[string]schema.Block{},
		DeprecationMessage:  "",
		Version:             1,
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description:         "Unique string identifier assembled as branchId/componentId/configId.",
				MarkdownDescription: "Unique string identifier assembled as branchId/componentId/configId.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"configuration_id": schema.StringAttribute{
				Description:         "Id of the configuration. If not specified, then will be autogenerated.",
				MarkdownDescription: "Id of the configuration. If not specified, then will be autogenerated.",
				Optional:            true,
				Computed:            true,
			},
			"component_id": schema.StringAttribute{
				Description:         "Id of the component.",
				MarkdownDescription: "Id of the component.",
				Required:            true,
			},
			"branch_id": schema.Int64Attribute{
				Description:         "Id of the branch. If not specified, then default branch will be used.",
				MarkdownDescription: "Id of the branch. If not specified, then default branch will be used.",
				Optional:            true,
				Computed:            true,
			},
			"name": schema.StringAttribute{
				Description: "Name of the configuration.",
				Required:    true,
			},
			"description": schema.StringAttribute{
				Description: "Description of the configuration.",
				Optional:    true,
				Computed:    true,
			},
			"change_description": schema.StringAttribute{
				Description: "Change description associated with the configuration change.",
				Optional:    true,
				Computed:    true,
			},
			"is_disabled": schema.BoolAttribute{
				Description: "Wheter configuration is enabled or disabled.",
				Optional:    true,
				Computed:    true,
			},
			"configuration": schema.StringAttribute{
				Description: "Content of the configuration specified as JSON string.",
				Optional:    true,
				Computed:    true,
			},
			"is_deleted": schema.BoolAttribute{
				Description: "Wheter configuration has been deleted or not.",
				Computed:    true,
			},
			"created": schema.StringAttribute{
				Description: "Timestamp of the configuration creation date.",
				Computed:    true,
			},
			"rows": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Description: "ID of the configuration row",
							Computed:    true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
						},
						"name": schema.StringAttribute{
							Description: "Name of the configuration row.",
							Required:    true,
						},
						"description": schema.StringAttribute{
							Description: "Description of the configuration row.",
							Optional:    true,
							Computed:    true,
						},
						"change_description": schema.StringAttribute{
							Description: "Change description associated with the configuration row change.",
							Optional:    true,
							Computed:    true,
						},
						"is_disabled": schema.BoolAttribute{
							Description: "Whether configuration row is enabled or disabled.",
							Optional:    true,
							Computed:    true,
						},
						"version": schema.Int64Attribute{
							Description: "Version of the configuration row.",
							Computed:    true,
						},
						"state": schema.StringAttribute{
							Description: "State of the configuration row.",
							Computed:    true,
						},
						"configuration_row": schema.StringAttribute{
							Description: "Content of the configuration row specified as JSON string.",
							Optional:    true,
							Computed:    true,
						},
					},
				},
				Description: "Rows for the configuration",
				Optional:    true,
			},
			"version": schema.Int64Attribute{
				Description: "Id of the version",
				Computed:    true,
			},
		},
	}
}

// Configure adds the provider configured client to the resource.
func (r *Resource) Configure(
	_ context.Context,
	req resource.ConfigureRequest,
	_ *resource.ConfigureResponse,
) {
	// Return silently if provider data is not available (yet)
	if req.ProviderData == nil {
		return
	}

	// Get the provider data - ignoring the type assertion success
	providerData, _ := req.ProviderData.(*providermodels.ProviderData)
	r.client = providerData.Client
	r.isTest = os.Getenv("TF_ACC") != "" //nolint: forbidigo

	// Set up the mapper
	r.base.Mapper = &ConfigMapper{
		RowHandler: &DefaultConfigRowHandler{
			Client: r.client,
			isTest: r.isTest,
		},
		isTest: r.isTest,
	}
}

// Create creates the resource and sets the initial Terraform state.
func (r *Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Info(ctx, "Creating configuration resource")

	// Use the base resource abstraction for Create
	r.base.ExecuteCreate(ctx, req, resp, func(ctx context.Context, plan ConfigModel) (*keboola.ConfigWithRows, error) {
		// Handle default branch if not specified
		if plan.BranchID.IsUnknown() {
			branch, err := r.client.GetDefaultBranchRequest().Send(ctx)
			if err != nil {
				return nil, fmt.Errorf("could not get default branch: %w", err)
			}
			plan.BranchID = types.Int64Value(int64(branch.ID))
		}

		// Execute the create operation using the mapper
		apiModel, err := r.base.Mapper.MapTerraformToAPI(ctx, ConfigModel{}, plan)
		if err != nil {
			return nil, fmt.Errorf("failed to map Terraform model to API: %w", err)
		}

		// Create configuration via API
		resConfig, err := r.client.CreateConfigRequest(apiModel, false).Send(ctx)
		if err != nil {
			return nil, fmt.Errorf("could not create configuration: %w", err)
		}

		return resConfig, nil
	})
}

// Read resource information.
func (r *Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Info(ctx, "Reading configuration resource")

	// Use the base resource abstraction for Read
	r.base.ExecuteRead(ctx, req, resp, func(ctx context.Context, state ConfigModel) (*keboola.ConfigWithRows, error) {
		// Create key from model
		key := keboola.ConfigKey{
			ID:          keboola.ConfigID(state.ConfigID.ValueString()),
			BranchID:    keboola.BranchID(state.BranchID.ValueInt64()),
			ComponentID: keboola.ComponentID(state.ComponentID.ValueString()),
		}

		// Get configuration
		config, err := r.client.GetConfigRequest(key).Send(ctx)
		if err != nil {
			return nil, fmt.Errorf("could not read Configuration %s: %w", GetConfigModelID(&state), err)
		}

		// Get rows separately
		rowKey := keboola.ConfigRowKey{
			ConfigID:    key.ID,
			BranchID:    key.BranchID,
			ComponentID: key.ComponentID,
		}

		// Fetch rows from API
		rows, err := r.client.ListConfigRowRequest(rowKey).Send(ctx)
		if err != nil {
			return nil, fmt.Errorf("could not read configuration rows: %w", err)
		}

		// Prepare configuration with rows for mapping
		configWithRows := &keboola.ConfigWithRows{
			Config: config,
			Rows:   *rows,
		}

		return configWithRows, nil
	})
}

// Update updates the resource.
func (r *Resource) Update(
	ctx context.Context,
	req resource.UpdateRequest,
	resp *resource.UpdateResponse,
) {
	tflog.Info(ctx, "Updating configuration resource")

	// Use the base resource abstraction for Update
	r.base.ExecuteUpdate(
		ctx,
		req,
		resp,
		func(ctx context.Context, state, plan ConfigModel) (
			*keboola.ConfigWithRows,
			error,
		) {
			// Preserve branch, component, and config IDs from state
			plan.BranchID = state.BranchID
			plan.ComponentID = state.ComponentID
			plan.ConfigID = state.ConfigID

			// Execute the update operation using the mapper
			apiModel, err := r.base.Mapper.MapTerraformToAPI(ctx, state, plan)
			if err != nil {
				return nil, fmt.Errorf("failed to map Terraform model to API: %w", err)
			}

			// Update configuration
			resConfig, err := r.client.UpdateConfigRequest(apiModel, nil).Send(ctx)
			if err != nil {
				return nil, fmt.Errorf("could not update configuration: %w", err)
			}

			return resConfig, nil
		})
}

// Delete deletes the resource.
func (r *Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Info(ctx, "Deleting configuration resource")

	// Use the base resource abstraction for Delete
	r.base.ExecuteDelete(ctx, req, resp, func(ctx context.Context, state ConfigModel) error {
		// Create key from model
		key := keboola.ConfigKey{
			ID:          keboola.ConfigID(state.ConfigID.ValueString()),
			BranchID:    keboola.BranchID(state.BranchID.ValueInt64()),
			ComponentID: keboola.ComponentID(state.ComponentID.ValueString()),
		}

		// Delete the configuration
		err := r.client.DeleteConfigRequest(key).SendOrErr(ctx)
		if err != nil {
			return fmt.Errorf("could not delete configuration: %w", err)
		}

		return nil
	})
}
