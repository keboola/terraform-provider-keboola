package configuration

import (
	"context"
	"fmt"
	"os"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/keboola/go-client/pkg/keboola"

	"terraform-provider-keboola/internal/providermodels"
)

// Ensure the implementation satisfies the expected interfaces
var (
	_ resource.Resource              = &Resource{}
	_ resource.ResourceWithConfigure = &Resource{}
)

// NewResource is a helper function to simplify the provider implementation
func NewResource() resource.Resource {
	return &Resource{}
}

// Resource is the configuration resource implementation
type Resource struct {
	// Base functionality with config model specifics
	base struct {
		mapper ConfigMapper
	}

	// Direct access to the API client for specific operations
	client *keboola.AuthorizedAPI
	isTest bool
}

// Metadata returns the resource type name
func (r *Resource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_component_configuration"
}

// Schema defines the schema for the resource
func (r *Resource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Manages component configurations (https://keboola.docs.apiary.io/#reference/components-and-configurations).",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description: "Unique string identifier assembled as branchId/componentId/configId.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"configuration_id": schema.StringAttribute{
				Description: "Id of the configuration. If not specified, then will be autogenerated.",
				Optional:    true,
				Computed:    true,
			},
			"component_id": schema.StringAttribute{
				Description: "Id of the component.",
				Required:    true,
			},
			"branch_id": schema.Int64Attribute{
				Description: "Id of the branch. If not specified, then default branch will be used.",
				Optional:    true,
				Computed:    true,
			},
			"name": schema.StringAttribute{
				Description: "Name of the configuration.",
				Required:    true,
			},
			"description": schema.StringAttribute{
				Description: "Description of the configuration.",
				Optional:    true,
				Computed:    true,
			},
			"change_description": schema.StringAttribute{
				Description: "Change description associated with the configuration change.",
				Optional:    true,
				Computed:    true,
			},
			"is_disabled": schema.BoolAttribute{
				Description: "Wheter configuration is enabled or disabled.",
				Optional:    true,
				Computed:    true,
			},
			"configuration": schema.StringAttribute{
				Description: "Content of the configuration specified as JSON string.",
				Optional:    true,
				Computed:    true,
			},
			"is_deleted": schema.BoolAttribute{
				Description: "Wheter configuration has been deleted or not.",
				Computed:    true,
			},
			"created": schema.StringAttribute{
				Description: "Timestamp of the configuration creation date.",
				Computed:    true,
			},
			"rows": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Description: "ID of the configuration row",
							Computed:    true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
						},
						"name": schema.StringAttribute{
							Description: "Name of the configuration row.",
							Required:    true,
						},
						"description": schema.StringAttribute{
							Description: "Description of the configuration row.",
							Optional:    true,
							Computed:    true,
						},
						"change_description": schema.StringAttribute{
							Description: "Change description associated with the configuration row change.",
							Optional:    true,
							Computed:    true,
						},
						"is_disabled": schema.BoolAttribute{
							Description: "Whether configuration row is enabled or disabled.",
							Optional:    true,
							Computed:    true,
						},
						"version": schema.Int64Attribute{
							Description: "Version of the configuration row.",
							Computed:    true,
						},
						"state": schema.StringAttribute{
							Description: "State of the configuration row.",
							Optional:    true,
							Computed:    true,
						},
						"configuration_row": schema.StringAttribute{
							Description: "Content of the configuration row specified as JSON string.",
							Optional:    true,
							Computed:    true,
						},
					},
				},
				Description: "Rows for the configuration",
				Optional:    true,
			},
			"version": schema.Int64Attribute{
				Description: "Id of the version",
				Computed:    true,
			},
		},
	}
}

// Configure adds the provider configured client to the resource
func (r *Resource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Return silently if provider data is not available (yet)
	if req.ProviderData == nil {
		return
	}

	// Get the provider data - ignoring the type assertion success
	providerData, _ := req.ProviderData.(*providermodels.ProviderData)
	r.client = providerData.Client
	r.isTest = os.Getenv("TF_ACC") != ""

	// Set up the mapper
	r.base.mapper = ConfigMapper{
		RowHandler: &DefaultConfigRowHandler{
			Client: r.client,
			isTest: r.isTest,
		},
		isTest: r.isTest,
	}
}

// Create creates the resource and sets the initial Terraform state
func (r *Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Info(ctx, "Creating configuration resource")

	// Get plan data
	var plan ConfigModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Validate the plan
	diags = r.base.mapper.ValidateTerraformModel(ctx, nil, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Handle default branch if not specified
	if plan.BranchID.IsUnknown() {
		branch, err := r.client.GetDefaultBranchRequest().Send(ctx)
		if err != nil {
			resp.Diagnostics.AddError(
				"Error creating configuration",
				fmt.Sprintf("Could not get default branch: %s", err.Error()),
			)
			return
		}
		plan.BranchID = types.Int64Value(int64(branch.ID))
	}

	// Convert to API model
	apiModel, err := r.base.mapper.MapTerraformToAPI(ctx, ConfigModel{}, plan)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error creating configuration",
			fmt.Sprintf("Failed to map Terraform model to API: %s", err.Error()),
		)
		return
	}

	// Create configuration via API
	resConfig, err := r.client.CreateConfigRequest(apiModel).Send(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error creating configuration",
			fmt.Sprintf("Could not create configuration: %s", err.Error()),
		)
		return
	}

	// Map API model back to Terraform model
	diags = r.base.mapper.MapAPIToTerraform(ctx, resConfig, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Set state
	diags = resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
}

// Read resource information
func (r *Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Info(ctx, "Reading configuration resource")

	// Get current state
	var state ConfigModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Create key from model
	key := keboola.ConfigKey{
		ID:          keboola.ConfigID(state.ConfigID.ValueString()),
		BranchID:    keboola.BranchID(state.BranchID.ValueInt64()),
		ComponentID: keboola.ComponentID(state.ComponentID.ValueString()),
	}

	// Get configuration
	config, err := r.client.GetConfigRequest(key).Send(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error Reading Configuration",
			fmt.Sprintf("Could not read Configuration %s: %s", GetConfigModelId(&state), err.Error()),
		)
		return
	}

	// Get rows separately
	rowKey := keboola.ConfigRowKey{
		ConfigID:    key.ID,
		BranchID:    key.BranchID,
		ComponentID: key.ComponentID,
	}

	// Fetch rows from API
	rows, err := r.client.ListConfigRowRequest(rowKey).Send(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reading configuration rows",
			fmt.Sprintf("Could not read configuration rows: %s", err.Error()),
		)
		return
	}

	// Prepare configuration with rows for mapping
	configWithRows := &keboola.ConfigWithRows{
		Config: config,
		Rows:   *rows,
	}

	// Map API model to Terraform model including rows
	diags = r.base.mapper.MapAPIToTerraform(ctx, configWithRows, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Set refreshed state
	diags = resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
}

// Update updates the resource
func (r *Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Info(ctx, "Updating configuration resource")

	// Get plan and state
	var plan, state ConfigModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	diags = req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Validate the plan
	diags = r.base.mapper.ValidateTerraformModel(ctx, &state, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	plan.BranchID = state.BranchID
	plan.ComponentID = state.ComponentID
	plan.ConfigID = state.ConfigID

	// Convert plan to API model
	apiModel, err := r.base.mapper.MapTerraformToAPI(ctx, state, plan)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error updating configuration",
			fmt.Sprintf("Failed to map Terraform model to API: %s", err.Error()),
		)
		return
	}

	// Update configuration
	resConfig, err := r.client.UpdateConfigRequest(apiModel, nil).Send(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error updating configuration",
			fmt.Sprintf("Could not update configuration: %s", err.Error()),
		)
		return
	}

	// Map API model back to Terraform model
	diags = r.base.mapper.MapAPIToTerraform(ctx, resConfig, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Set state
	diags = resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
}

// Delete deletes the resource
func (r *Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Info(ctx, "Deleting configuration resource")

	// Get current state
	var state ConfigModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Create key from model
	key := keboola.ConfigKey{
		ID:          keboola.ConfigID(state.ConfigID.ValueString()),
		BranchID:    keboola.BranchID(state.BranchID.ValueInt64()),
		ComponentID: keboola.ComponentID(state.ComponentID.ValueString()),
	}

	// Delete the configuration
	err := r.client.DeleteConfigRequest(key).SendOrErr(ctx)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error Deleting Configuration",
			fmt.Sprintf("Could not delete configuration: %s", err.Error()),
		)
		return
	}
}
